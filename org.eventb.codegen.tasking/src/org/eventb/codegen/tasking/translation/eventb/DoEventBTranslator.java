package org.eventb.codegen.tasking.translation.eventb;

import static org.eventb.codegen.tasking.utils.CodeGenTaskingUtils.AND_SYMBOL;
import static org.eventb.codegen.tasking.utils.CodeGenTaskingUtils.ELEMENT_OF;
import static org.eventb.codegen.tasking.utils.CodeGenTaskingUtils.FALSE_SYMBOL;
import static org.eventb.codegen.tasking.utils.CodeGenTaskingUtils.NOT_SYMBOL;

import java.util.ArrayList;

import org.eclipse.emf.common.util.EList;
import org.eventb.codegen.tasking.AbstractEventBTranslator;
import org.eventb.codegen.tasking.TaskingTranslationManager;
import org.eventb.codegen.tasking.TaskingTranslationUnhandledTypeException;
import org.eventb.emf.core.EventBElement;
import org.eventb.emf.core.machine.Event;
import org.eventb.emf.core.machine.Guard;
import org.eventb.emf.core.machine.Parameter;
import org.eventb.emf.core.machine.impl.MachineFactoryImpl;
import org.eventb.emf.core.machine.impl.MachineImpl;

import compositeControl.Do;

public class DoEventBTranslator extends AbstractEventBTranslator {

	@Override
	public String translate(EventBElement source, MachineImpl machine,
			String waitGuard, String forceGuardName,
			TaskingTranslationManager translationManager)
			throws TaskingTranslationUnhandledTypeException {

		Do actualSource = (Do) source;
		String newWaitGuard = waitGuard;

		// Don't want to fully translate the Do event, just add a PC guard to it
		if (actualSource.getTaskBody() != null) {
			Event newEvent = actualSource.getTaskBody().getEvent();

			if (actualSource.getFinally() == null) {
				// generate a new event to set the continue flag
				String eventName = "GENERATED" + newEvent.getName() + "Finally";
				Event finallyEvent = MachineFactoryImpl.eINSTANCE.createEvent();
				finallyEvent.setGenerated(true);
				finallyEvent.setName(eventName);

				Guard guard = MachineFactoryImpl.eINSTANCE.createGuard();

				if (newEvent.getGuards().size() > 0) {
					// ONLY ADD GUARDS THAT ARE NOT TYPING GUARDS OF A PARAMETER
					// Eg. make sure if lhs or rhs is a variable, that it exists
					// somewhere
					ArrayList<Guard> guards = getNonParameterTypingGuards(
							newEvent.getGuards(), newEvent.getParameters());

					if (guards.size() > 0) {

						String guardString = NOT_SYMBOL + "("
								+ guards.get(0).getPredicate();

						for (int i = 1; i < guards.size(); i++) {
							guardString += " " + AND_SYMBOL + " "
									+ guards.get(i).getPredicate();
						}
						guardString += ")";
						guard.setPredicate(guardString);
					} else {
						guard.setPredicate(FALSE_SYMBOL);
					}
				} else {
					guard.setPredicate(FALSE_SYMBOL);
				}

				guard.setName("grd1");
				guard.setGenerated(true);

				EventBTranslatorHelpers.addNewGuard(finallyEvent, waitGuard);

				finallyEvent.getGuards().add(guard);
				machine.getEvents().add(finallyEvent);

				newWaitGuard = eventName;

				EventBTranslatorHelpers.disableProgramCounter(finallyEvent,
						waitGuard);
				EventBTranslatorHelpers
						.addNewProgramCounter(eventName, machine);
				EventBTranslatorHelpers.enableProgramCounter(finallyEvent,
						newWaitGuard);

			} else {
				// use the finally
				newWaitGuard = translationManager.translateToEventB(
						actualSource.getFinally(), machine, waitGuard);
			}

			// Add the guard at the end, so that the finally, if autogenerated,
			// can get all
			// the real guards quickly and easily
			EventBTranslatorHelpers.addNewGuard(newEvent, waitGuard);
		}

		return newWaitGuard;
	}

	private boolean isParameterTyping(Guard g, EList<Parameter> parameters) {
		String gText = g.getPredicate();

		if (gText.contains(ELEMENT_OF)) {
			String[] split = gText.split(ELEMENT_OF);
			String name = split[0].trim();

			for (Parameter p : parameters) {
				if (p.getName().trim().equals(name)) {
					return true;
				}
			}
		}

		return false;
	}

	private ArrayList<Guard> getNonParameterTypingGuards(EList<Guard> guards,
			EList<Parameter> parameters) {
		ArrayList<Guard> output = new ArrayList<Guard>();

		for (Guard g : guards) {
			if (!isParameterTyping(g, parameters)) {
				output.add(g);
			}
		}

		return output;
	}

}
